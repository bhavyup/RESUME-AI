service/resume/TalkService
```java
package com.resumebuilder.ai_resume_api.service.resume;

import com.resumebuilder.ai_resume_api.dto.ReorderRequestDto;
import com.resumebuilder.ai_resume_api.dto.resume.*;
import com.resumebuilder.ai_resume_api.entity.resume.TalkEntity;
import com.resumebuilder.ai_resume_api.entity.embedded.TalkLink;
import com.resumebuilder.ai_resume_api.enums.TalkLinkType;
import com.resumebuilder.ai_resume_api.enums.TalkRole;
import com.resumebuilder.ai_resume_api.enums.TalkStatus;
import com.resumebuilder.ai_resume_api.enums.TalkType;
import com.resumebuilder.ai_resume_api.exception.BadRequestException;
import com.resumebuilder.ai_resume_api.exception.NotFoundException;
import com.resumebuilder.ai_resume_api.mapper.ResumeMapper;
import com.resumebuilder.ai_resume_api.repository.resume.ResumeRepository;
import com.resumebuilder.ai_resume_api.repository.resume.TalkRepository;
import com.resumebuilder.ai_resume_api.security.SecurityUtil;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

@Service
@Transactional
public class TalkService {

    private final TalkRepository talkRepository;
    private final ResumeRepository resumeRepository;
    private final ResumeMapper resumeMapper;

    public TalkService(TalkRepository talkRepository, ResumeRepository resumeRepository, ResumeMapper resumeMapper) {
        this.talkRepository = talkRepository;
        this.resumeRepository = resumeRepository;
        this.resumeMapper = resumeMapper;
    }

    @Transactional(readOnly = true)
    public List<TalkResponseDto> list(Long resumeId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var list = talkRepository.findAllByResume_IdOrderByDisplayOrderAscIdAsc(resume.getId());
        return resumeMapper.toTalkDtoList(list);
    }

    @Transactional(readOnly = true)
    public TalkResponseDto getOne(Long resumeId, Long talkId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = talkRepository.findByIdAndResume_Id(talkId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException("The talk does not belong to the specified resume."));
        return resumeMapper.toDto(e);
    }

    public TalkResponseDto create(Long resumeId, TalkRequestDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));

        validateDates(dto.startDate(), dto.endDate());

        var e = new TalkEntity();
        e.setResume(resume);

        e.setTitle(dto.title());
        e.setEventName(dto.eventName());
        e.setOrganizer(dto.organizer());
        e.setTrack(dto.track());

        e.setType(parseType(dto.type()));
        e.setRole(parseRole(dto.role()));
        var status = parseStatus(dto.status());

        e.setStartDate(dto.startDate());
        e.setEndDate(dto.endDate());

        e.setVirtual(Boolean.TRUE.equals(dto.isVirtual()));
        e.setVenue(dto.venue());
        e.setCity(dto.city());
        e.setRegion(dto.region());
        e.setCountry(dto.country());

        e.setLanguage(dto.language());
        e.setAudienceSize(dto.audienceSize());

        e.setSlidesUrl(dto.slidesUrl());
        e.setVideoUrl(dto.videoUrl());
        e.setEventUrl(dto.eventUrl());
        e.setCoverImageUrl(dto.coverImageUrl());

        e.setAbstractText(dto.abstractText());
        e.setDescription(dto.description());
        e.setNotes(dto.notes());

        if (dto.coSpeakers() != null)
            e.setCoSpeakers(new ArrayList<>(dto.coSpeakers()));
        if (dto.keywords() != null)
            e.setKeywords(new ArrayList<>(dto.keywords()));
        if (dto.links() != null)
            e.setLinks(mapLinks(dto.links()));

        if (status == null)
            status = deriveStatus(e.getStartDate(), e.getEndDate());
        e.setStatus(status);

        Integer maxOrder = talkRepository.findMaxDisplayOrderByResume_Id(resume.getId());
        e.setDisplayOrder((maxOrder == null ? -1 : maxOrder) + 1);

        e = talkRepository.save(e);
        return resumeMapper.toDto(e);
    }

    public TalkResponseDto update(Long resumeId, Long talkId, TalkUpdateDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = talkRepository.findByIdAndResume_Id(talkId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException("The talk does not belong to the specified resume."));

        if (dto.version() == null)
            throw new BadRequestException("Talk version is required for update.");
        if (!dto.version().equals(e.getVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for talk id=" + talkId);
        }

        LocalDate newStart = dto.startDate() != null ? dto.startDate() : e.getStartDate();
        LocalDate newEnd = dto.endDate() != null ? dto.endDate() : e.getEndDate();
        validateDates(newStart, newEnd);

        if (dto.title() != null)
            e.setTitle(dto.title());
        if (dto.eventName() != null)
            e.setEventName(dto.eventName());
        if (dto.organizer() != null)
            e.setOrganizer(dto.organizer());
        if (dto.track() != null)
            e.setTrack(dto.track());

        if (dto.type() != null)
            e.setType(parseType(dto.type()));
        if (dto.role() != null)
            e.setRole(parseRole(dto.role()));

        if (dto.startDate() != null)
            e.setStartDate(dto.startDate());
        if (dto.endDate() != null)
            e.setEndDate(dto.endDate());

        if (dto.isVirtual() != null)
            e.setVirtual(dto.isVirtual());
        if (dto.venue() != null)
            e.setVenue(dto.venue());
        if (dto.city() != null)
            e.setCity(dto.city());
        if (dto.region() != null)
            e.setRegion(dto.region());
        if (dto.country() != null)
            e.setCountry(dto.country());

        if (dto.language() != null)
            e.setLanguage(dto.language());
        if (dto.audienceSize() != null)
            e.setAudienceSize(dto.audienceSize());

        if (dto.slidesUrl() != null)
            e.setSlidesUrl(dto.slidesUrl());
        if (dto.videoUrl() != null)
            e.setVideoUrl(dto.videoUrl());
        if (dto.eventUrl() != null)
            e.setEventUrl(dto.eventUrl());
        if (dto.coverImageUrl() != null)
            e.setCoverImageUrl(dto.coverImageUrl());

        if (dto.abstractText() != null)
            e.setAbstractText(dto.abstractText());
        if (dto.description() != null)
            e.setDescription(dto.description());
        if (dto.notes() != null)
            e.setNotes(dto.notes());

        if (dto.coSpeakers() != null)
            e.setCoSpeakers(new ArrayList<>(dto.coSpeakers()));
        if (dto.keywords() != null)
            e.setKeywords(new ArrayList<>(dto.keywords()));
        if (dto.links() != null)
            e.setLinks(mapLinks(dto.links()));

        if (dto.status() != null) {
            e.setStatus(parseStatus(dto.status()));
        } else {
            e.setStatus(deriveStatus(e.getStartDate(), e.getEndDate()));
        }

        e = talkRepository.save(e);
        return resumeMapper.toDto(e);
    }

    public void delete(Long resumeId, Long talkId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = talkRepository.findByIdAndResume_Id(talkId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException("The talk does not belong to the specified resume."));
        talkRepository.delete(e);
    }

    public void reorder(Long resumeId, ReorderRequestDto req) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));

        if (!req.resumeVersion().equals(resume.getVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for resume during talks reorder.");
        }

        var items = talkRepository.findAllByResume_IdOrderByDisplayOrderAscIdAsc(resume.getId());
        if (items.size() != req.orderedIds().size()) {
            throw new BadRequestException("orderedIds size must match talks count.");
        }

        var byId = new HashMap<Long, TalkEntity>();
        for (var it : items)
            byId.put(it.getId(), it);

        var seen = new HashSet<Long>();
        int pos = 0;
        for (var id : req.orderedIds()) {
            if (!byId.containsKey(id))
                throw new NotFoundException("Talk not found in this resume: id=" + id);
            if (!seen.add(id))
                throw new BadRequestException("Duplicate id in orderedIds: " + id);
            byId.get(id).setDisplayOrder(pos++);
        }

        talkRepository.saveAll(items);
    }

    // ------------------------ Helpers ------------------------

    private void validateDates(LocalDate start, LocalDate end) {
        if (start != null && end != null && end.isBefore(start)) {
            throw new BadRequestException("endDate cannot be before startDate.");
        }
    }

    private TalkStatus deriveStatus(LocalDate start, LocalDate end) {
        var today = LocalDate.now();
        if (start == null && end == null)
            return TalkStatus.SCHEDULED;
        LocalDate effectiveEnd = (end != null) ? end : start;
        if (effectiveEnd != null && effectiveEnd.isBefore(today))
            return TalkStatus.DELIVERED;
        if (start != null && start.isAfter(today))
            return TalkStatus.SCHEDULED;
        return TalkStatus.SCHEDULED;
    }

    private List<TalkLink> mapLinks(List<TalkLinkDto> links) {
        var out = new ArrayList<TalkLink>();
        for (var l : links) {
            var tl = new TalkLink();
            tl.setType(parseLinkType(l.type()));
            tl.setTitle(l.title());
            tl.setUrl(l.url());
            out.add(tl);
        }
        return out;
    }

    private TalkType parseType(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return TalkType.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid type. Allowed: TALK, WORKSHOP, PANEL, KEYNOTE, WEBINAR, POSTER, LIGHTNING, DEMO");
        }
    }

    private TalkRole parseRole(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return TalkRole.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid role. Allowed: SPEAKER, CO_SPEAKER, PANELIST, MODERATOR, HOST, ORGANIZER, TRAINER");
        }
    }

    private TalkStatus parseStatus(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return TalkStatus.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException("Invalid status. Allowed: SCHEDULED, DELIVERED, CANCELLED, POSTPONED");
        }
    }

    private TalkLinkType parseLinkType(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return TalkLinkType.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid link.type. Allowed: SLIDES, VIDEO, EVENT, REPO, DEMO, PHOTOS, PRESS, OTHER");
        }
    }
}
```

service/resume/ReferenceService
```java
package com.resumebuilder.ai_resume_api.service.resume;

import com.resumebuilder.ai_resume_api.dto.ReorderRequestDto;
import com.resumebuilder.ai_resume_api.dto.resume.*;
import com.resumebuilder.ai_resume_api.entity.resume.*;
import com.resumebuilder.ai_resume_api.enums.ReferenceContactMethod;
import com.resumebuilder.ai_resume_api.enums.ReferenceRelationship;
import com.resumebuilder.ai_resume_api.exception.BadRequestException;
import com.resumebuilder.ai_resume_api.exception.NotFoundException;
import com.resumebuilder.ai_resume_api.mapper.ResumeMapper;
import com.resumebuilder.ai_resume_api.repository.resume.ReferenceRepository;
import com.resumebuilder.ai_resume_api.repository.resume.ResumeRepository;
import com.resumebuilder.ai_resume_api.security.SecurityUtil;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Service
@Transactional
public class ReferenceService {

    private final ReferenceRepository referenceRepository;
    private final ResumeRepository resumeRepository;
    private final ResumeMapper resumeMapper;

    public ReferenceService(ReferenceRepository referenceRepository, ResumeRepository resumeRepository,
            ResumeMapper resumeMapper) {
        this.referenceRepository = referenceRepository;
        this.resumeRepository = resumeRepository;
        this.resumeMapper = resumeMapper;
    }

    @Transactional(readOnly = true)
    public List<ReferenceResponseDto> list(Long resumeId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var list = referenceRepository.findAllByResume_IdOrderByDisplayOrderAscIdAsc(resume.getId());
        return resumeMapper.toReferenceDtoList(list);
    }

    @Transactional(readOnly = true)
    public ReferenceResponseDto getOne(Long resumeId, Long referenceId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = referenceRepository.findByIdAndResume_Id(referenceId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException("The reference does not belong to the specified resume."));
        return resumeMapper.toDto(e);
    }

    public ReferenceResponseDto create(Long resumeId, ReferenceRequestDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));

        var e = new ReferenceEntity();
        e.setResume(resume);

        e.setName(dto.name());
        e.setTitle(dto.title());
        e.setCompany(dto.company());

        e.setRelationship(parseRelationship(dto.relationship()));
        e.setPreferredContactMethod(parseContactMethod(dto.preferredContactMethod()));

        e.setEmail(dto.email());
        e.setPhone(dto.phone());
        e.setLinkedinUrl(dto.linkedinUrl());
        e.setWebsiteUrl(dto.websiteUrl());

        e.setConsentToShare(Boolean.TRUE.equals(dto.consentToShare()));
        e.setVisible(Boolean.TRUE.equals(dto.visible()));

        e.setRelationshipNote(dto.relationshipNote());
        e.setNote(dto.note());
        e.setLastVerifiedOn(dto.lastVerifiedOn());

        validateVisibilityConsent(e.isVisible(), e.isConsentToShare(), e.getEmail(), e.getPhone(), e.getLinkedinUrl(),
                e.getWebsiteUrl());

        Integer maxOrder = referenceRepository.findMaxDisplayOrderByResume_Id(resume.getId());
        e.setDisplayOrder((maxOrder == null ? -1 : maxOrder) + 1);

        e = referenceRepository.save(e);
        return resumeMapper.toDto(e);
    }

    public ReferenceResponseDto update(Long resumeId, Long referenceId, ReferenceUpdateDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = referenceRepository.findByIdAndResume_Id(referenceId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException("The reference does not belong to the specified resume."));

        if (dto.version() == null)
            throw new BadRequestException("Reference version is required for update.");
        if (!dto.version().equals(e.getVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for reference id=" + referenceId);
        }

        if (dto.name() != null)
            e.setName(dto.name());
        if (dto.title() != null)
            e.setTitle(dto.title());
        if (dto.company() != null)
            e.setCompany(dto.company());

        if (dto.relationship() != null)
            e.setRelationship(parseRelationship(dto.relationship()));
        if (dto.preferredContactMethod() != null)
            e.setPreferredContactMethod(parseContactMethod(dto.preferredContactMethod()));

        if (dto.email() != null)
            e.setEmail(dto.email());
        if (dto.phone() != null)
            e.setPhone(dto.phone());
        if (dto.linkedinUrl() != null)
            e.setLinkedinUrl(dto.linkedinUrl());
        if (dto.websiteUrl() != null)
            e.setWebsiteUrl(dto.websiteUrl());

        if (dto.consentToShare() != null)
            e.setConsentToShare(dto.consentToShare());
        if (dto.visible() != null)
            e.setVisible(dto.visible());

        if (dto.relationshipNote() != null)
            e.setRelationshipNote(dto.relationshipNote());
        if (dto.note() != null)
            e.setNote(dto.note());
        if (dto.lastVerifiedOn() != null)
            e.setLastVerifiedOn(dto.lastVerifiedOn());

        validateVisibilityConsent(e.isVisible(), e.isConsentToShare(), e.getEmail(), e.getPhone(), e.getLinkedinUrl(),
                e.getWebsiteUrl());

        e = referenceRepository.save(e);
        return resumeMapper.toDto(e);
    }

    public void delete(Long resumeId, Long referenceId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = referenceRepository.findByIdAndResume_Id(referenceId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException("The reference does not belong to the specified resume."));
        referenceRepository.delete(e);
    }

    public void reorder(Long resumeId, ReorderRequestDto req) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));

        if (!req.resumeVersion().equals(resume.getVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for resume during references reorder.");
        }

        var items = referenceRepository.findAllByResume_IdOrderByDisplayOrderAscIdAsc(resume.getId());
        if (items.size() != req.orderedIds().size()) {
            throw new BadRequestException("orderedIds size must match references count.");
        }

        var byId = new HashMap<Long, ReferenceEntity>();
        for (var it : items)
            byId.put(it.getId(), it);

        var seen = new HashSet<Long>();
        int pos = 0;
        for (var id : req.orderedIds()) {
            if (!byId.containsKey(id))
                throw new NotFoundException("Reference not found in this resume: id=" + id);
            if (!seen.add(id))
                throw new BadRequestException("Duplicate id in orderedIds: " + id);
            byId.get(id).setDisplayOrder(pos++);
        }

        referenceRepository.saveAll(items);
    }

    // Settings: "References available on request"
    @Transactional(readOnly = true)
    public ReferencesSettingsDto getSettings(Long resumeId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        return new ReferencesSettingsDto(resume.getVersion(), resume.isReferencesOnRequest());
    }

    public void updateSettings(Long resumeId, ReferencesSettingsDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        if (!resume.getVersion().equals(dto.resumeVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for resume while updating references settings.");
        }
        resume.setReferencesOnRequest(Boolean.TRUE.equals(dto.referencesOnRequest()));
        // JPA dirty checking will persist
    }

    // ------------------------ Helpers ------------------------

    private void validateVisibilityConsent(boolean visible, boolean consent, String email, String phone,
            String linkedin, String website) {
        boolean hasContact = (email != null && !email.isBlank())
                || (phone != null && !phone.isBlank())
                || (linkedin != null && !linkedin.isBlank())
                || (website != null && !website.isBlank());
        if (visible && hasContact && !consent) {
            throw new BadRequestException("visible=true with contact info requires consentToShare=true.");
        }
    }

    private ReferenceRelationship parseRelationship(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return ReferenceRelationship.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid relationship. Allowed: MANAGER, SUPERVISOR, PEER, COLLEAGUE, DIRECT_REPORT, CLIENT, STAKEHOLDER, PROFESSOR, TEACHER, MENTOR, ADVISOR, COACH, OTHER");
        }
    }

    private ReferenceContactMethod parseContactMethod(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return ReferenceContactMethod.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid preferredContactMethod. Allowed: EMAIL, PHONE, LINKEDIN, WEBSITE, OTHER");
        }
    }
}
```

service/resume/VolunteeringService
```java
package com.resumebuilder.ai_resume_api.service.resume;

import com.resumebuilder.ai_resume_api.dto.ReorderRequestDto;
import com.resumebuilder.ai_resume_api.dto.resume.*;
import com.resumebuilder.ai_resume_api.entity.resume.VolunteeringEntity;
import com.resumebuilder.ai_resume_api.entity.embedded.VolunteerLink;
import com.resumebuilder.ai_resume_api.enums.*;
import com.resumebuilder.ai_resume_api.exception.BadRequestException;
import com.resumebuilder.ai_resume_api.exception.NotFoundException;
import com.resumebuilder.ai_resume_api.mapper.ResumeMapper;
import com.resumebuilder.ai_resume_api.repository.resume.ResumeRepository;
import com.resumebuilder.ai_resume_api.repository.resume.VolunteeringRepository;
import com.resumebuilder.ai_resume_api.security.SecurityUtil;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

@Service
@Transactional
public class VolunteeringService {

    private final VolunteeringRepository volunteeringRepository;
    private final ResumeRepository resumeRepository;
    private final ResumeMapper resumeMapper;

    public VolunteeringService(VolunteeringRepository volunteeringRepository, ResumeRepository resumeRepository,
            ResumeMapper resumeMapper) {
        this.volunteeringRepository = volunteeringRepository;
        this.resumeRepository = resumeRepository;
        this.resumeMapper = resumeMapper;
    }

    @Transactional(readOnly = true)
    public List<VolunteeringResponseDto> list(Long resumeId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var list = volunteeringRepository.findAllByResume_IdOrderByDisplayOrderAscIdAsc(resume.getId());
        return resumeMapper.toVolunteerDtoList(list);
    }

    @Transactional(readOnly = true)
    public VolunteeringResponseDto getOne(Long resumeId, Long volunteeringId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = volunteeringRepository.findByIdAndResume_Id(volunteeringId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException(
                        "The volunteering entry does not belong to the specified resume."));
        return resumeMapper.toDto(e);
    }

    public VolunteeringResponseDto create(Long resumeId, VolunteeringRequestDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));

        validateDates(dto.startDate(), dto.endDate());

        var e = new VolunteeringEntity();
        e.setResume(resume);

        e.setTitle(dto.title());
        e.setOrganization(dto.organization());

        e.setType(parseType(dto.type()));
        e.setStatus(parseStatus(dto.status()));
        e.setEngagementMode(parseMode(dto.engagementMode()));
        e.setCause(parseCause(dto.cause()));

        e.setStartDate(dto.startDate());
        e.setEndDate(dto.endDate());
        e.setHours(dto.hours());

        e.setCity(dto.city());
        e.setRegion(dto.region());
        e.setCountry(dto.country());

        e.setOrgWebsiteUrl(dto.orgWebsiteUrl());
        e.setCoverImageUrl(dto.coverImageUrl());

        e.setDescription(dto.description());
        e.setNotes(dto.notes());

        if (dto.responsibilities() != null)
            e.setResponsibilities(new ArrayList<>(dto.responsibilities()));
        if (dto.impacts() != null)
            e.setImpacts(new ArrayList<>(dto.impacts()));
        if (dto.mentees() != null)
            e.setMentees(new ArrayList<>(dto.mentees()));
        if (dto.events() != null)
            e.setEvents(new ArrayList<>(dto.events()));
        if (dto.teachingTopics() != null)
            e.setTeachingTopics(new ArrayList<>(dto.teachingTopics()));
        if (dto.keywords() != null)
            e.setKeywords(new ArrayList<>(dto.keywords()));
        if (dto.referenceUrls() != null)
            e.setReferenceUrls(new ArrayList<>(dto.referenceUrls()));
        if (dto.links() != null)
            e.setLinks(mapLinks(dto.links()));

        // Derive status if not provided
        if (e.getStatus() == null)
            e.setStatus(deriveStatus(e.getStartDate(), e.getEndDate()));

        Integer maxOrder = volunteeringRepository.findMaxDisplayOrderByResume_Id(resume.getId());
        e.setDisplayOrder((maxOrder == null ? -1 : maxOrder) + 1);

        e = volunteeringRepository.save(e);
        return resumeMapper.toDto(e);
    }

    public VolunteeringResponseDto update(Long resumeId, Long volunteeringId, VolunteeringUpdateDto dto) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = volunteeringRepository.findByIdAndResume_Id(volunteeringId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException(
                        "The volunteering entry does not belong to the specified resume."));

        if (dto.version() == null)
            throw new BadRequestException("Volunteering version is required for update.");
        if (!dto.version().equals(e.getVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for volunteering id=" + volunteeringId);
        }

        LocalDate newStart = dto.startDate() != null ? dto.startDate() : e.getStartDate();
        LocalDate newEnd = dto.endDate() != null ? dto.endDate() : e.getEndDate();
        validateDates(newStart, newEnd);

        if (dto.title() != null)
            e.setTitle(dto.title());
        if (dto.organization() != null)
            e.setOrganization(dto.organization());

        if (dto.type() != null)
            e.setType(parseType(dto.type()));
        if (dto.status() != null)
            e.setStatus(parseStatus(dto.status()));
        if (dto.engagementMode() != null)
            e.setEngagementMode(parseMode(dto.engagementMode()));
        if (dto.cause() != null)
            e.setCause(parseCause(dto.cause()));

        if (dto.startDate() != null)
            e.setStartDate(dto.startDate());
        if (dto.endDate() != null)
            e.setEndDate(dto.endDate());
        if (dto.hours() != null)
            e.setHours(dto.hours());

        if (dto.city() != null)
            e.setCity(dto.city());
        if (dto.region() != null)
            e.setRegion(dto.region());
        if (dto.country() != null)
            e.setCountry(dto.country());

        if (dto.orgWebsiteUrl() != null)
            e.setOrgWebsiteUrl(dto.orgWebsiteUrl());
        if (dto.coverImageUrl() != null)
            e.setCoverImageUrl(dto.coverImageUrl());

        if (dto.description() != null)
            e.setDescription(dto.description());
        if (dto.notes() != null)
            e.setNotes(dto.notes());

        if (dto.responsibilities() != null)
            e.setResponsibilities(new ArrayList<>(dto.responsibilities()));
        if (dto.impacts() != null)
            e.setImpacts(new ArrayList<>(dto.impacts()));
        if (dto.mentees() != null)
            e.setMentees(new ArrayList<>(dto.mentees()));
        if (dto.events() != null)
            e.setEvents(new ArrayList<>(dto.events()));
        if (dto.teachingTopics() != null)
            e.setTeachingTopics(new ArrayList<>(dto.teachingTopics()));
        if (dto.keywords() != null)
            e.setKeywords(new ArrayList<>(dto.keywords()));
        if (dto.referenceUrls() != null)
            e.setReferenceUrls(new ArrayList<>(dto.referenceUrls()));
        if (dto.links() != null)
            e.setLinks(mapLinks(dto.links()));

        // If status not explicitly set, keep it consistent with date changes
        if (dto.status() == null)
            e.setStatus(deriveStatus(e.getStartDate(), e.getEndDate()));

        e = volunteeringRepository.save(e);
        return resumeMapper.toDto(e);
    }

    public void delete(Long resumeId, Long volunteeringId) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));
        var e = volunteeringRepository.findByIdAndResume_Id(volunteeringId, resume.getId())
                .orElseThrow(() -> new AccessDeniedException(
                        "The volunteering entry does not belong to the specified resume."));
        volunteeringRepository.delete(e);
    }

    public void reorder(Long resumeId, ReorderRequestDto req) {
        String username = SecurityUtil.currentUsername();
        var resume = resumeRepository.findByIdAndUser_Username(resumeId, username)
                .orElseThrow(() -> new NotFoundException("Resume not found"));

        if (!req.resumeVersion().equals(resume.getVersion())) {
            throw new com.resumebuilder.ai_resume_api.exception.OptimisticLockingException(
                    "Version mismatch for resume during volunteering reorder.");
        }

        var items = volunteeringRepository.findAllByResume_IdOrderByDisplayOrderAscIdAsc(resume.getId());
        if (items.size() != req.orderedIds().size()) {
            throw new BadRequestException("orderedIds size must match volunteering count.");
        }

        var byId = new HashMap<Long, VolunteeringEntity>();
        for (var it : items)
            byId.put(it.getId(), it);

        var seen = new HashSet<Long>();
        int pos = 0;
        for (var id : req.orderedIds()) {
            if (!byId.containsKey(id))
                throw new NotFoundException("Volunteering entry not found in this resume: id=" + id);
            if (!seen.add(id))
                throw new BadRequestException("Duplicate id in orderedIds: " + id);
            byId.get(id).setDisplayOrder(pos++);
        }

        volunteeringRepository.saveAll(items);
    }

    // ------------------------ Helpers ------------------------

    private void validateDates(LocalDate start, LocalDate end) {
        if (start != null && end != null && end.isBefore(start)) {
            throw new BadRequestException("endDate cannot be before startDate.");
        }
    }

    private VolunteerStatus deriveStatus(LocalDate start, LocalDate end) {
        var today = LocalDate.now();
        if (start == null && end == null)
            return VolunteerStatus.ONGOING;
        if (end != null && end.isBefore(today))
            return VolunteerStatus.COMPLETED;
        if (start != null && start.isAfter(today))
            return VolunteerStatus.PLANNED;
        return VolunteerStatus.ONGOING;
    }

    private List<VolunteerLink> mapLinks(List<VolunteerLinkDto> links) {
        var out = new ArrayList<VolunteerLink>();
        for (var l : links) {
            var vl = new VolunteerLink();
            vl.setType(parseLinkType(l.type()));
            vl.setTitle(l.title());
            vl.setUrl(l.url());
            out.add(vl);
        }
        return out;
    }

    private VolunteerType parseType(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return VolunteerType.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid type. Allowed: VOLUNTEER, LEADERSHIP, MENTORING, ORGANIZING, TEACHING, TUTORING, COACHING, PRO_BONO, COMMUNITY");
        }
    }

    private VolunteerStatus parseStatus(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return VolunteerStatus.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException("Invalid status. Allowed: ONGOING, COMPLETED, PLANNED, PAUSED");
        }
    }

    private VolunteerEngagementMode parseMode(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return VolunteerEngagementMode.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException("Invalid engagementMode. Allowed: IN_PERSON, VIRTUAL, HYBRID");
        }
    }

    private VolunteerCause parseCause(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return VolunteerCause.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid cause. Allowed: EDUCATION, ENVIRONMENT, HEALTH, ANIMALS, TECHNOLOGY, ARTS, SPORTS, COMMUNITY, HUMAN_RIGHTS, DISASTER_RELIEF, OTHER");
        }
    }

    private VolunteerLinkType parseLinkType(String v) {
        if (v == null || v.isBlank())
            return null;
        try {
            return VolunteerLinkType.valueOf(v.trim().toUpperCase());
        } catch (IllegalArgumentException ex) {
            throw new BadRequestException(
                    "Invalid link.type. Allowed: ORG, EVENT, PROJECT, MEDIA, PRESS, REPO, PHOTOS, OTHER");
        }
    }
}
```

